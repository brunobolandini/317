create_intial_runs(string input_file_name, int run_size, int num_files, string tempdir, PriorityQueue pqueue) {
        int[] runs = new int [num_files];
        int total_runs = 0;
        FileInputStream stream - new FileInputStream(input_file_name);	DataInputStream in = new DataInputStream (stream);
        int output_file = 0;
        file writer fw = new FileWriter((tempdir +” “+output_file+”.txt “), true);
        for(int i=o; i<run_size; i++) {
            if(in.available()!=0){
                pqueue.AddElement((new QueueElement(Integer.parseInt(in.readLine()), output_file)));
            }
        }
        while(in.available() != 0) {
            int element_writtter = pqueue.getFirst().getElement();
            fw.write(element_written + “\n”);
            int element_new = Integer.parseInt(in.readLine());
            if (element_new < element_written){
                pqueue.addToQueueForNextRun(new QueueElement(element_new, output_file));
            }
            else {
                pqueue.addToRootHeap(new QueueElement(element_new, output_file));
            }
            if(pqueue.getHeapSize()==0) {
                fw.close();
                runs[output_file]++;
                total_runs++;
                output_file = (int) (Math.random() * (num_files-2)); //TO DO BETTER METHOD fibonacci sequence?
                pw = new FileWriter((tempdir+output_file+”.txt”), true);
                pqueue.reHeap(0);
            }
            int lastHeapSize = pqueue.getHeapSize();
            while(pqueue.getHeapSize()>0) {
                fw.write(pqueue.removeFirst().getElement()+”\n”);
            }
            fw.close();
            runs[output_file]++;
            total_runs++;
            if(lastHeapSize < 7) {
                output_file = (int) Mathrandom() * (num_files-2));
                fw = new FileWriter((tempdir+output_file+”.txt”), true);
                pqueue.reHeap(lastHeapSize);
                while(pqueue.getHeapSize()>0){
                    fw.write(pqueue.removeFirst().getElement()+”\n”);
                }
                fw.close();
                runs[output_file]++;
                total_runs++;
            }
            System.out.println(“Total initial runs: “+total_runs+”distribution: “+Arrays.toString(runs));
            in.close();
        }


        public class heap {
        	private int Left(int element_index) { //root its zero
        		return ((element_index*2)+1);
        	}
        	private int Right (int element_index) {
        		return ((element_index*2)+2);
        	}
        	private int Parent (int element_index) {
        		return ((element_index - 1) /2);
        	}
        	private void Swap (int element_index_x, int element_index_y, QueueElement[] heap_array) {
        		QueueElement element_temp = heap_array[element_index_x];
        		heap_array[element_index_x] = heap_array[element_index_y];
        		heap_array[element_index_y] = element_temp;
        	}
        	private int SwapWithChild (int element_index, QueueElement[] heap_array, int heap_size) {
        		int element_left_index = Left(element_index);
        		int element_right_index = Right(element_index);
        		int element_smallest_index = element_index;
        		if(element_right_index < heap_size) {
        			if(heap_array[element_left_index].getElement() < heap_array[element_right_index]()) {
        				element_smallest_index = element_left_index;
        			}
        			else {
        				element_smallest_index = element_right_index;
        			}
        			if(heap_array[element_index].getElement() < heap_array[element_smallest_index].getElement(); {
        				element_smallest_index = element_index;
        			}
        		}
        		else if(element_left_index <heap_size) {
        			if (heap_array[element_index].getElement() > heap_array[element_left_index].getElement()){
        				element_smallest_index = element_left_index;
        			}
        		}
        		if(heap_array[element_index].getElement() > heap_array[element_left_index].getElement()) {
        			Swap(element_index, element_smallest_index, heap_array);
        		}
        		return element_smallest_index;
        	}

        	public void DownHeap (QueueElement[] heap_array, int heap_size) {
        		int swapping_index = 0;
        		int swapped_index = SwapWithChild(0, heap_array, heap_size);
        		while (swapped_index != swapping_index) {
        			swapping_index = swapped_index;
        			swapped_index = SwapWithChild(swapped_index, heap_array, heap_size);
        		}
        	}

        	public SwapWithparent (int index, QueueElement[] heap_array) {

        	}

        	public void addElement(QueueElement new_element, QueueElement[] heap_array, int heap_size) {

        	}